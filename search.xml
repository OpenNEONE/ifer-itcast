<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据在内存中的存储形式]]></title>
    <url>%2F2019%2F05%2F25%2Fsnake-question%2F</url>
    <content type="text"><![CDATA[学习贪吃蛇时，往蛇身体增加最后一节，当时代码是直接这样写的 this.body.push({ x: last.x, y: last.y, color: last.color })，有些同学问 last 这个变量保存的数据和 { x: last.x, y: last.y, color: last.color } “长的一样”，为什么不能直接 this.body.push(last) 呢？ 基本数据类型存储要说清楚上面的问题，首先大家要明白不同数据类型在内存中的存储形式是怎样的。我们都知道 JS 中的数据类型分为 2 大类，分别是： 基本数据类型：Number、String、Boolean、Null、Undefined、Symbol(ES6) 复杂数据类型：Object(包括数组、对象、函数、正则) 其中基本数据类型存储在栈内存中，他们是按值存放的，例如： 1234var age1 = 18;var age2 = age1;age2 = 20;console.log(age1, age2); // 18 20 上面代码在内存中的表现形式如下： 复杂数据类型存储复杂数据类型的真实数据是存放在堆内存中的，变量保存的只是在栈内存中的一个地址，这个地址指向堆内存中数据。例如： 1234var obj1 = &#123; age: 18 &#125;;var obj2 = obj1;obj2.age = 20; // obj2 是改变堆内存中的同一份数据console.log(obj1.age); // 所以 obj1 的数据也被影响了，结果是 20 上面代码在内存中的表现形式如下： 解释贪吃蛇的问题讲贪吃蛇时，关于蛇如何吃到食物我们说了这么一段话：在蛇运动时，判断蛇头的坐标是否与食物的坐标吻合，如果吻合，则往蛇身体后增加一节，然后再随机食物的坐标即可，代码如下： 12345678if (headX === food.x &amp;&amp; headY === food.y) &#123; // Step1: 获取蛇的最后一节 var last = this.body[this.body.length - 1]; // Step2: 添加到身体的最后 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // Step3: 随机随机食物坐标 food.render(map);&#125; 如果直接 this.body.push(last) 的话，相当于每次添加的还是堆内存中的同一个 last，那在下次 move 修改数据的时候就会相互影响，无论你往后面 push 多少项 last，在修改到最前面的 three 时也会把后面的给修改掉（因为都是堆内存中的同一份数据），所以你看到的结果是后面的数据都是重复的，对应到页面上也就是最后一节的元素都是覆盖在一起的。测试代码如下： 12345678910var one = &#123;x: 26, y: 14, color: "red"&#125;;var two = &#123;x: 25, y: 14, color: "blue"&#125;;var three = &#123;x: 24, y: 14, color: "blue"&#125;;var arr = [one, two, three, three];for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr); 该如何解决12345678910111213141516171819var arr = [ &#123;x: 26, y: 14, color: "red"&#125;, &#123;x: 25, y: 14, color: "blue"&#125;, &#123;x: 24, y: 14, color: "blue"&#125;];var last = arr[arr.length - 1];// 每次造一个全新的对象var newObj = &#123; x: last.x, y: last.y, color: last.color &#125;;// 或者拷贝原来的对象// var newObj = JSON.parse(JSON.stringify(last));arr.push(newObj);for (var i = arr.length - 1; i &gt; 0; i--) &#123; arr[i].x = arr[i - 1].x; arr[i].y = arr[i - 1].y;&#125;console.log(arr);]]></content>
      <categories>
        <category>JS 高级</category>
      </categories>
      <tags>
        <tag>贪吃蛇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的隐式转换]]></title>
    <url>%2F2019%2F05%2F24%2Finvisible-transform%2F</url>
    <content type="text"></content>
      <categories>
        <category>JS 基础</category>
      </categories>
      <tags>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发全选按钮的几种思路]]></title>
    <url>%2F2019%2F05%2F22%2Fselect-all%2F</url>
    <content type="text"><![CDATA[需求：点击全选，选中上面所有的列表项；点击列表项中的每一个水果，如果有未选中则取消全选按钮，如果都选中了则激活全选按钮。 常规操作点击每个列表选项时，遍历所有列表选项并检查是否有未选中的，如果有则可以确定全选按钮的状态为未选中，否则全选按钮置为选中。 1234567891011121314151617181920212223242526272829303132var oAllInput = document.querySelector('#all');var aInput = document.querySelectorAll('ul input');// 点击全选 input 时根据自己的状态来控制其他列表项的 inputoAllInput.onchange = function() &#123; for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].checked = this.checked; &#125;&#125;;// 每次点击每一个列表项的 input 时，判断全选的 input 是否需要被选中for(var i = 0; i &lt; aInput.length; i ++) &#123; aInput[i].onclick = function() &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; var bBar = true; for(var i = 0; i &lt; aInput.length; i ++) &#123; // 发现有一个没选中的 if(!aInput[i].checked) &#123; bBar = false; // 发现有一个没选中的也就可以断定 oAllInput 的状态了，就没有必要再进行下去了 // 当然你不写 break 逻辑上也是对的，只是存在性能浪费 break; &#125; &#125; oAllInput.checked = bBar; &#125;;&#125; 注意细节思路和上面一样，下面的写法也是可以的，但有一点需要注意：点击列表中的每一项进行循环时，碰到未选中的一定要跳出循环，不然前面全选按钮的状态都会被最后一个按钮的状态所覆盖。 12345678910111213141516171819for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; if (!this.checked) &#123; // 如果当前点击的按钮未选中，那就可以直接确定全选按钮的状态了 oAllInput.checked = false; // 也就没有必要进行下去了 return; &#125; for (var i = 0; i &lt; aInput.length; i++) &#123; if (!aInput[i].checked) &#123; oAllInput.checked = false; // 这里的 break 是必须要加的！不然全选按钮的状态永远是以最后一个的选中状态为准，这并不是我们所希望的 break; &#125; else &#123; oAllInput.checked = true; &#125; &#125; &#125;;&#125; 其他方法每次点击列表中的按钮时，获取所有已选中 input 的长度，并判断已选中 input 的 length 是否等于所有 input 的 length，如果相等，就可以激活全选按钮啦，否则则取消全选。 1234567891011for (var i = 0; i &lt; aInput.length; i++) &#123; aInput[i].onclick = function () &#123; var aInputChecked = document.querySelectorAll('ul input:checked'); // 已选中 length 等于所有 length 就证明全选中了，也就可以激活全选按钮啦 if (aInputChecked.length === aInput.length) &#123; oAllInput.checked = true; &#125; else &#123; oAllInput.checked = false; &#125; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>全选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排他思想]]></title>
    <url>%2F2019%2F05%2F21%2Fkill-other%2F</url>
    <content type="text"><![CDATA[上课我们在做点击当前按钮高亮，其他按钮重置为默认颜色的需求时，用到了“排他思想”，思路是：第一步，先干掉所有的；第二步，再操作自己的，简单明了，相信大家都比较清楚了！这里我再给大家做个总结，顺便再拓展一下其他的实现思路 ~ 排完思想需求：有 5 个按钮，点击当前按钮变红，其他按钮恢复默认颜色 123456&lt;!-- HTML 结构 --&gt;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;button&gt;3&lt;/button&gt;&lt;button&gt;4&lt;/button&gt;&lt;button&gt;5&lt;/button&gt; 123456789101112var aBtn = document.querySelectorAll('button');for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].onclick = function() &#123; // Step1: 先干掉所有人，“排完” for(var i = 0; i &lt; aBtn.length; i ++) &#123; aBtn[i].style.backgroundColor = ''; &#125; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; &#125;;&#125; 排兄思想1234567&lt;script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$("button").on("click", function() &#123; // 先操作自己的，再干掉所有的兄弟，“排兄” $(this).css("background", "red").siblings().css("background", "");&#125;);&lt;/script&gt; 排上思想1234567891011121314var aBtn = document.querySelectorAll('button');var prev = 0;for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onclick = function () &#123; // Step1: 先干掉上一个，“排上” aBtn[prev].style.backgroundColor = ""; // Step2: 再操作自己的 this.style.backgroundColor = 'red'; // Step3: 操作完别忘了把自己也变成“上一个” prev = this.index; &#125;;&#125;]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>排他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认清 Node.appendChild()]]></title>
    <url>%2F2019%2F05%2F19%2FappendChild%2F</url>
    <content type="text"><![CDATA[Node.appendChild() 方法用于将一个节点添加到指定父节点的子节点列表的末尾，但在具体使用时还有其他一些需要我们关注的细节，以及对应的应用场景。 常规操作大家都清楚 appendChild 可以把创建好的元素插入到另一个元素内容的最后面，常规操作如下： 123456// 创建元素var oDiv = document.createElement('div');// 给创建好的元素加点内容oDiv.innerHTML = 'hello world';// 添加到 body 里面document.body.appendChild(oDiv); 需要注意上面代码必然没有任何问题，但这里还有一点需要大家注意的是，appendChild 在插入已存在元素的时候其实是做了两件事的： 先把原来已存在的元素删除 再进行后续的添加操作 具体是什么意思呢？大家看下面的例子就清楚了。需求：每次点击按钮把上面 ul 中的第一个元素移动到下面的 ul 中： 1234567891011121314151617181920&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;li&gt;ddd&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;插入下面&lt;/button&gt;&lt;ul id="ul2"&gt;&lt;/ul&gt;&lt;script&gt;// 选择元素var oUl1 = document.querySelector('#ul1');var oBtn = document.querySelector('#btn');var oUl2 = document.querySelector('#ul2');oBtn.onclick = function() &#123; var oLi = oUl1.children[0]; // 每次点击按钮确实在 oUl2 中添加了一个新的元素，但同时 oUl1 中也相应少了这个元素 // 所以 appendChild 时相当于偷偷帮我们做了这么一步操作：oUl1.removeChild(oLi); oUl2.appendChild(oLi);&#125;;&lt;/script&gt; 实际应用好，现在我们清楚了当用 appendChild 插入已存在元素时会先删除之前再进行插入，那明白这个特性有什么实际的用处吗？答案是肯定的。例如下面一个需求，点击按钮，根据元素中的数字大小对这组元素进行排序： 123456789&lt;!-- HTML 结构 --&gt;&lt;ul id="ul1"&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;button id="btn"&gt;点击&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233// 选择元素var oUl1 = document.querySelector('#ul1');var aLi = oUl1.querySelectorAll('li');var oBtn = document.querySelector('#btn');// 把伪数组 aLi 中的每一项都放到数组里面，目的是为了进行排序var arr = [];for(var i = 0; i &lt; aLi.length; i ++) &#123; arr.push(aLi[i]);&#125;oBtn.onclick = function () &#123; // 这就是我们熟悉的冒泡排序，你还记得吗 for (var i = 0; i &lt; arr.length - 1; i++) &#123; // 需要走 arr.length - 1 轮 for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; // 每轮比较 arr.length - i - 1 次 var prevNum = parseFloat(arr[j].innerText); var nextNum = parseFloat(arr[j + 1].innerText); if (prevNum &gt; nextNum) &#123; // 不能对伪数组中其中一些直接赋值，例如：aLi[j] = aLi[j+1]，所以需要把伪数组转换成数组后再进行排序 var temp = null; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; // 此时 arr 中装的已经是排好序的一堆 li 元素了 for(var i = 0; i &lt; arr.length; i ++) &#123; // 分别把排好序的数组中的每个元素插入到 oUl1 内容的最后 // 注意每次插入的同时也会把 oUl1 中那个相同的元素先给干掉，所以 oUl1 中也就不会存在重复元素的问题 oUl1.appendChild(arr[i]); &#125;&#125;; 优化代码这里优化相关的代码我们并没有学（不建议查看），我这里也提供一种较佳实战，是给你们以后看的（甚至是工作后），优化后的 JS 代码如下： 123456789101112const oUl1 = document.querySelector('#ul1');const aLi = oUl1.querySelectorAll('li');const oBtn = document.querySelector('#btn');oBtn.addEventListener('click', () =&gt; &#123; // Array.from 可以把伪数组转成数组，sort 的原理就是上面写的冒泡排序 Array.from(aLi).sort((li1, li2) =&gt; &#123; return parseFloat(li1.innerText) - parseFloat(li2.innerText); &#125;).forEach(li =&gt; &#123; oUl1.appendChild(li); &#125;)&#125;);]]></content>
      <categories>
        <category>Web API</category>
      </categories>
      <tags>
        <tag>appendChild</tag>
      </tags>
  </entry>
</search>
